#include "arduino_secrets.h"
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <DallasTemperature.h>
#include <OneWire.h>
#include <NTPClient.h>

#include <WiFiUdp.h>

#include "file1.h"

/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/b55d9e8c-c99f-4fa3-b79a-a3547ca0a3ca

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String weatherCondition;
  CloudColor setColor;
  float avgNightTemp;
  float awakeHours;
  float electricityRate;
  float homeTemp;
  float outdoorTemp;
  float sleepHours;
  float stepCounter;
  CloudColoredLight lightSwitch;
  bool rainNotification;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#define ONE_WIRE_BUS 1
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, 60000); // Update every 60 seconds


int ledRPin = 3; // Red LED pin
int ledGPin = 4; // Green LED pin
int ledBPin = 5; // Blue LED pin (not used in this case)

// OpenWeatherMap API credentials
const char *apiKey = "3a72b6b08fd87f4722a84a307e115dd8";
const char *location = "London,UK";
const char *apiEndpoint = "http://api.openweathermap.org/data/2.5/weather";

void setup()
{
    // Initialize serial and wait for port to open:
    Serial.begin(9600);
    delay(1500); // Wait for Serial Monitor to open

    // Defined in thingProperties.h
    initProperties();

    // Configure LED pins as output
    pinMode(ledRPin, OUTPUT);
    pinMode(ledGPin, OUTPUT);
    pinMode(ledBPin, OUTPUT);

    sensors.begin(); // Initialize temperature sensor

    // Connect to Arduino IoT Cloud
    ArduinoCloud.begin(ArduinoIoTPreferredConnection);

    // Initialize NTP Client
    timeClient.begin();
  
    // Debug level for IoT Cloud
    setDebugMessageLevel(2);
    ArduinoCloud.printDebugInfo();
}

void loop()
{
    ArduinoCloud.update(); // Update IoT Cloud connection


    // Request temperature reading
    sensors.requestTemperatures();
    homeTemp = sensors.getTempCByIndex(0);

    if (homeTemp == DEVICE_DISCONNECTED_C)
    {
        Serial.println("Error: Sensor disconnected!");
        return; // Skip the rest of the loop if sensor is disconnected
    }

    // Fetch outdoor weather data
    Serial.println("Fetching Weather.");
    fetchWeather();
    Serial.println("Fetching Tariffs.");
    fetchTariffs();
  
    timeClient.update(); // Update time from NTP server

    int currentHour = timeClient.getHours(); // Get the current hour in 24-hour format
    Serial.print("Current Hour: ");
    Serial.println(currentHour);

    // Check if the time is between 11 PM and 8 AM
    if (currentHour >= 23 || currentHour < 8) {
        Serial.println("time range is");
        Serial.println(currentHour);
        Serial.println("Calling processSleepDataAndUpdate(); during specified time range.");
        processSleepDataAndUpdate();
        ArduinoCloud.update(); // Update IoT Cloud connection
    } else {
        Serial.println("Outside specified time range, skipping processSleepDataAndUpdate();");
    }
    
    

    // Check the state of the lightSwitch
    if (lightSwitch.getSwitch())
    { // Use the `getSwitch()` method to check if the light is ON

        // Turn the light red if temperature < 20Â°C, green otherwise
        if (homeTemp < 20)
        {
            analogWrite(ledRPin, 255); // Turn Red LED on
            analogWrite(ledGPin, 0);   // Turn Green LED off
            analogWrite(ledBPin, 0);   // Turn Blue LED off
        }
        else
        {
            analogWrite(ledRPin, 0);   // Turn Red LED off
            analogWrite(ledGPin, 255); // Turn Green LED on
            analogWrite(ledBPin, 0);   // Turn Blue LED off
        }
    }

    delay(60000); // Wait 1 second before the next loop
}

#include <HTTPClient.h>
#include <ArduinoJson.h>




void fetchTariffs() {
  HTTPClient http;
  const char* tariffEndpoint = "https://api.octopus.energy/v1/products/AGILE-18-02-21/electricity-tariffs/E-1R-AGILE-18-02-21-C/standard-unit-rates/?";
  
  http.begin(tariffEndpoint);
  int httpResponseCode = http.GET();

  if (httpResponseCode == 200) { // HTTP OK
    String payload = http.getString();
    DynamicJsonDocument doc(8192); // Adjust size as needed

    DeserializationError error = deserializeJson(doc, payload);
    if (!error) {
      Serial.println("Tariff Data:");
      for (JsonObject rate : doc["results"].as<JsonArray>()) {
        const char* startTime = rate["valid_from"]; // ISO8601 format
        const char* endTime = rate["valid_to"];    // ISO8601 format
        float unitRate = rate["value_inc_vat"];    // Rate in pence/kWh


        electricityRate = unitRate;
        ArduinoCloud.update();

        delay(100); // To prevent overwhelming the Serial monitor
      }
    } else {
      Serial.println("Failed to parse tariff data.");
      Serial.println(error.c_str());
    }
  } else {
    Serial.print("Error fetching tariffs: HTTP ");
    Serial.println(httpResponseCode);
  }

  http.end(); // Close the HTTP connection
}

void onSetColorChange()
{
    uint8_t r, g, b; // Variables to store RGB values

    // Get RGB values from the CloudColor variable
    setColor.getValue().getRGB(r, g, b);
    if (lightSwitch.getSwitch())
    {
        // Write the RGB values to the LED
        analogWrite(ledRPin, r);
        analogWrite(ledGPin, g);
        analogWrite(ledBPin, b);
    }
    else
    {
        analogWrite(ledRPin, 0); // Turn Red LED off
        analogWrite(ledGPin, 0); // Turn Green LED on
        analogWrite(ledBPin, 0); // Turn Blue LED off
    }
}

unsigned long lastNotificationTime = 0;                    // Timestamp of the last notification
const unsigned long notificationCooldown = 30 * 60 * 1000; // 30 minutes in milliseconds

void fetchWeather()
{
    HTTPClient http;
    String url = String(apiEndpoint) + "?q=" + location + "&appid=" + apiKey + "&units=metric";

    http.begin(url);
    int httpResponseCode = http.GET();

    if (httpResponseCode == 200)
    { // HTTP OK
        String payload = http.getString();
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);

        if (!error)
        {
            // Update outdoor temperature and weather condition
            float newOutdoorTemp = doc["main"]["temp"];
            if (newOutdoorTemp != outdoorTemp)
            {
                outdoorTemp = newOutdoorTemp;
            }

            String newWeatherCondition = doc["weather"][0]["description"].as<String>();
            if (newWeatherCondition != weatherCondition)
            {
                weatherCondition = newWeatherCondition;
            }

            // Check conditions for a notification
            if ((outdoorTemp < 10 || weatherCondition.indexOf("rain") != -1))
            {
                unsigned long currentTime = millis(); // Current time in milliseconds

                if (currentTime - lastNotificationTime > notificationCooldown)
                {
                    rainNotification = true;            // Trigger notification
                    lastNotificationTime = currentTime; // Update last notification time
                    Serial.println("Notification triggered!");
                }
                else
                {
                    rainNotification = false; // Cooldown active, no notification
                    Serial.println("Notification cooldown active.");
                }
            }
            else
            {
                rainNotification = false; // Condition no longer met
            }
        }
        else
        {
            Serial.println("Error parsing weather data.");
        }
    }
    else
    {
        Serial.print("Error fetching weather data: HTTP ");
        Serial.println(httpResponseCode);
    }
    http.end(); // Close the HTTP connection
}

/*
  Since LightSwitch is READ_WRITE variable, onLightSwitchChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLightSwitchChange()
{
    if (lightSwitch.getSwitch())
    {
    }
    else
    {
        analogWrite(ledRPin, 0); // Turn Red LED off
        analogWrite(ledGPin, 0); // Turn Green LED on
        analogWrite(ledBPin, 0); // Turn Blue LED off
    }
}

void onRainNotificationChange()
{
    // Placeholder function to avoid linker error
    // No action needed since rainNotification is updated in the sketch
}

/*
  Since ManualSleepHours is READ_WRITE variable, onManualSleepHoursChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onManualSleepHoursChange()
{
    // Add your code here to act upon ManualSleepHours change
}

/*
  Since SleepTracker is READ_WRITE variable, onSleepTrackerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSleepTrackerChange()
{
    // Add your code here to act upon SleepTracker change
}

/*
  Since StepCounter is READ_WRITE variable, onStepCounterChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onStepCounterChange()
{
    // Add your code here to act upon StepCounter change
}

/*
  Since SleepHours is READ_WRITE variable, onSleepHoursChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSleepHoursChange()
{
    // Add your code here to act upon SleepHours change
}


void processSleepDataAndUpdate()
{
    DynamicJsonDocument doc(4096); // Adjust the size for larger JSON files
    DeserializationError error = deserializeJson(doc, file1Data);

    if (error)
    {
        Serial.println("Failed to parse JSON");
        Serial.println(error.c_str());
        return;
    }

    // Loop through each record in the JSON array
    for (JsonObject record : doc.as<JsonArray>())
    {
        const char *date = record["Date"];
        float timeAwake = record["Time awake_hr_"];
        float timeCore = record["Time core_hr_"];

    

        // Update the `sleepHours` variable in Arduino Cloud
        sleepHours = timeCore;
        awakeHours = timeAwake;

        // Force update
        ArduinoCloud.update();

        Serial.print("Updating sleepHours in IoT Cloud: ");
        Serial.println(sleepHours);

        Serial.print("Updating awakeHours in IoT Cloud: ");
        Serial.println(awakeHours);
        // Delay between updates to simulate live data processing
        delay(60000); // Adjust this delay as needed
    }
}

/*
  Since AwakeHours is READ_WRITE variable, onAwakeHoursChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAwakeHoursChange()
{
    // Add your code here to act upon AwakeHours change
}



